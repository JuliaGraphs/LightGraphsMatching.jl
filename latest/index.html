<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · LightGraphsMatching</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightGraphsMatching</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Getting started</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Getting started</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphs/LightGraphsMatching.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="LightGraphsMatching.jl:-matching-algorithms-for-LightGraphs-1" href="#LightGraphsMatching.jl:-matching-algorithms-for-LightGraphs-1">LightGraphsMatching.jl: matching algorithms for LightGraphs</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphsMatching.MatchingResult" href="#LightGraphsMatching.MatchingResult"><code>LightGraphsMatching.MatchingResult</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">type MatchingResult{T}
    weight::T
    mate::Vector{Int}
end</code></pre><p>A type representing the result of a matching algorithm.</p><pre><code class="language-none">weight: total weight of the matching

mate:    `mate[i] = j` if vertex `i` is matched to vertex `j`.
         `mate[i] = -1` for unmatched vertices.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphsMatching.jl/blob/84b45bbec17cbf07dd50441b9a751603761bbd9d/src/LightGraphsMatching.jl#L6-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphsMatching.maximum_weight_matching" href="#LightGraphsMatching.maximum_weight_matching"><code>LightGraphsMatching.maximum_weight_matching</code></a> — <span class="docstring-category">Function</span>.</div><div><p>maximum_weight_matching{T &lt;:Real}(g::Graph, w::Dict{Edge,T} = Dict{Edge,Int64}())</p><p>Given a graph <code>g</code> and an edgemap <code>w</code> containing weights associated to edges, returns a matching with the maximum total weight. <code>w</code> is a dictionary that maps edges i =&gt; j to weights. If no weight parameter is given, all edges will be considered to have weight 1 (results in max cardinality matching)</p><p>The efficiency of the algorithm depends on the input graph:</p><ul><li><p>If the graph is bipartite, then the LP relaxation is integral.</p></li><li><p>If the graph is not bipartite, then it requires a MIP solver and</p></li></ul><p>the computation time may grow exponentially.</p><p>The package JuMP.jl and one of its supported solvers is required.</p><p>Returns MatchingResult containing:</p><ul><li><p>a solve status (indicating whether the problem was solved to optimality)</p></li><li><p>the optimal cost</p></li><li><p>a list of each vertex&#39;s match (or -1 for unmatched vertices)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphsMatching.jl/blob/84b45bbec17cbf07dd50441b9a751603761bbd9d/src/maximum_weight_matching.jl#L1-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphsMatching.maximum_weight_maximal_matching" href="#LightGraphsMatching.maximum_weight_maximal_matching"><code>LightGraphsMatching.maximum_weight_maximal_matching</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">maximum_weight_maximal_matching{T&lt;:Real}(g, w::Dict{Edge,T})
maximum_weight_maximal_matching{T&lt;:Real}(g, w::Dict{Edge,T}, cutoff)</code></pre><p>Given a bipartite graph <code>g</code> and an edgemap <code>w</code> containing weights associated to edges, returns a matching with the maximum total weight among the ones containing the greatest number of edges.</p><p>Edges in <code>g</code> not present in <code>w</code> will not be considered for the matching.</p><p>The algorithm relies on a linear relaxation on of the matching problem, which is guaranteed to have integer solution on bipartite graps.</p><p>Eventually a <code>cutoff</code> argument can be given, to reduce computational times excluding edges with weights lower than the cutoff.</p><p>The package JuMP.jl and one of its supported solvers is required.</p><p>The returned object is of type <code>MatchingResult</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphsMatching.jl/blob/84b45bbec17cbf07dd50441b9a751603761bbd9d/src/lp.jl#L1-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphsMatching.minimum_weight_perfect_matching" href="#LightGraphsMatching.minimum_weight_perfect_matching"><code>LightGraphsMatching.minimum_weight_perfect_matching</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">minimum_weight_perfect_matching{T&lt;:Real}(g, w::Dict{Edge,T})
minimum_weight_perfect_matching{T&lt;:Real}(g, w::Dict{Edge,T}, cutoff)</code></pre><p>Given a graph <code>g</code> and an edgemap <code>w</code> containing weights associated to edges, returns a matching with the mimimum total weight among the ones containing exactly <code>nv(g)/2</code> edges.</p><p>Edges in <code>g</code> not present in <code>w</code> will not be considered for the matching.</p><p>This function relies on the BlossomV.jl package, a julia wrapper around Kolmogorov&#39;s BlossomV algorithm.</p><p>Eventually a <code>cutoff</code> argument can be given, to the reduce computational time excluding edges with weights higher than the cutoff.</p><p>The returned object is of type <code>MatchingResult</code>.</p><p>In case of error try to change the optional argument <code>tmaxscale</code> (default is <code>tmaxscale=10</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphsMatching.jl/blob/84b45bbec17cbf07dd50441b9a751603761bbd9d/src/blossomv.jl#L1-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphsMatching.dict_to_arr-Union{Tuple{E}, Tuple{Int64,JuMP.JuMPArray{T,1,Tuple{Array{E,1}}}}, Tuple{T}} where E&lt;:LightGraphs.SimpleGraphs.SimpleEdge where T&lt;:Real" href="#LightGraphsMatching.dict_to_arr-Union{Tuple{E}, Tuple{Int64,JuMP.JuMPArray{T,1,Tuple{Array{E,1}}}}, Tuple{T}} where E&lt;:LightGraphs.SimpleGraphs.SimpleEdge where T&lt;:Real"><code>LightGraphsMatching.dict_to_arr</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns an array of mates from a dictionary that maps edges to {0,1} </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphsMatching.jl/blob/84b45bbec17cbf07dd50441b9a751603761bbd9d/src/maximum_weight_matching.jl#L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphsMatching.cutoff_weights-Union{Tuple{AbstractArray{T,2},R}, Tuple{R}, Tuple{T}} where R&lt;:Real where T&lt;:Real" href="#LightGraphsMatching.cutoff_weights-Union{Tuple{AbstractArray{T,2},R}, Tuple{R}, Tuple{T}} where R&lt;:Real where T&lt;:Real"><code>LightGraphsMatching.cutoff_weights</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cutoff_weights copies the weight matrix with all elements below cutoff set to 0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphsMatching.jl/blob/84b45bbec17cbf07dd50441b9a751603761bbd9d/src/lp.jl#L103-L105">source</a></section><p>This is the documentation page for <code>LightGraphsMatching</code>.  In all documentation examples, we assume LightGraphsMatching has been imported into scope and that LightGraphs is available with the alias <code>lg</code>:</p><pre><code class="language-julia">using LightGraphsMatching
import LightGraphs
const lg = LightGraphs</code></pre><footer><hr/></footer></article></body></html>
